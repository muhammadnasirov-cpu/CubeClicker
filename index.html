<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Spacebar Clicker</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #0d1117;
            font-family: 'Inter', sans-serif;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }

        canvas {
            display: block;
            touch-action: none;
        }

        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            pointer-events: none;
            padding: 2rem;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .counter-card {
            background-color: rgba(30, 41, 59, 0.9);
            padding: 1rem 2rem;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            text-align: center;
            color: white;
            transition: transform 0.1s ease-out;
            border: 1px solid #334155;
            pointer-events: auto;
        }

        /* Modal specific styles */
        #cheat-modal {
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 100;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="game-container">
        
        <!-- RESTART BUTTON (Hidden) -->
        <button id="restart-button" class="fixed top-2 left-2 text-xs font-bold text-red-500 opacity-20 hover:opacity-100 transition-opacity p-2 rounded-lg bg-gray-900/50 z-50 pointer-events-auto" data-confirm="false">
            RESTART
        </button>

        <!-- RANK CARD (TOP-LEFT) -->
        <div class="absolute top-8 left-8 w-64 max-w-full pointer-events-none">
            <div class="counter-card p-4" id="rank-display">
                <p class="text-sm uppercase text-gray-400">Current Rank</p>
                <p class="text-3xl font-extrabold text-red-400 mt-1" id="current-rank-name">Recruit</p>
            </div>
        </div>

        <div id="ui-overlay">
            <!-- Click Counter Card (STAYS CENTERED AT TOP) -->
            <div class="counter-card" id="click-counter">
                <p class="text-sm uppercase text-gray-400">Jumps / Clicks</p>
                <p class="text-5xl font-extrabold text-indigo-400 mt-1">0</p>
            </div>
        </div>

        <!-- ACHIEVEMENTS CARD MOVED TO TOP-RIGHT VIA ABSOLUTE POSITIONING -->
        <div class="absolute top-8 right-8 w-64 max-w-full pointer-events-none">
            <div class="bg-gray-800/80 p-3 rounded-xl border border-gray-700 pointer-events-auto">
                <h3 class="text-sm font-bold text-gray-300 mb-2 border-b border-gray-700 pb-1">ACHIEVEMENTS PROGRESS</h3>
                <ul id="achievement-list" class="space-y-3">
                    <!-- Achievement items will be inserted here by JavaScript -->
                </ul>
            </div>
        </div>
    </div>

    <!-- Notification Area (for unlocked achievements) -->
    <div id="notification-area" class="fixed bottom-4 right-4 z-50 space-y-2 pointer-events-none">
        <!-- Notifications appear here -->
    </div>

    <!-- CHEAT CODE MODAL -->
    <div id="cheat-modal" class="fixed inset-0 flex items-center justify-center hidden">
        <div class="bg-gray-800 p-8 rounded-xl shadow-2xl w-96 border-2 border-indigo-500 pointer-events-auto">
            <h2 class="text-2xl font-bold text-white mb-4">Enter Cheat Code</h2>
            <p class="text-sm text-gray-400 mb-4">Press **Enter** to submit or **Escape** to close.</p>
            <input 
                id="cheat-input" 
                type="text" 
                class="w-full p-3 rounded-lg bg-gray-700 text-white focus:outline-none focus:ring-2 focus:ring-indigo-500"
                placeholder="Type code here"
            >
        </div>
    </div>
    <!-- END CHEAT CODE MODAL -->

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, onSnapshot, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        let scene, camera, renderer, cube, gridHelper, cubeLight;
        let clickCount = 0;
        let cubeVelocity = 0;
        let isSpacebarPressed = false; 
        let isHackrbandActive = false;
        const cheatCode = "HACKRBAND";
        const gravity = -0.005;
        const jumpForce = 0.1;
        const cubeBaseY = 0.5;
        const gravityIncreaseFactor = 0.3; 

        // Base camera constants for zoom effect
        const baseCameraZ = 4;
        const baseCameraY = 3;
        const zoomFactor = 2.0; 
        let cubeZOffset = 0;
        let cameraZOffset = 0;
        const clickZImpulse = 0.3; 
        const springBackSpeed = 0.1; 

        // Firebase Globals
        let app, db, auth;
        let userId = null;
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;

        // UI elements
        const counterElement = document.getElementById('click-counter').querySelector('p.text-5xl');
        const counterCard = document.getElementById('click-counter');
        const gameContainer = document.getElementById('game-container');
        const achievementListElement = document.getElementById('achievement-list');
        const notificationArea = document.getElementById('notification-area');
        const rankNameElement = document.getElementById('current-rank-name'); 
        const modal = document.getElementById('cheat-modal'); 
        const cheatInput = document.getElementById('cheat-input'); 
        const restartButton = document.getElementById('restart-button'); 
        
        // --- RANK DEFINITIONS (UNCHANGED) ---
        const ranks = [
            { clicks: 1, name: 'Recruit' },
            { clicks: 100, name: 'Rookie' },
            { clicks: 200, name: 'Private 2' },
            { clicks: 400, name: 'Private 1' },
            { clicks: 800, name: 'Specialist' },
            { clicks: 1000, name: 'Corporal' },
            { clicks: 1200, name: 'Captain' },
            { clicks: 1400, name: 'Major' },
            { clicks: 1600, name: 'General' },
            { clicks: 1800, name: 'Advanced' },
            { clicks: 2000, name: 'Assassin' },
            { clicks: 3000, name: 'Elite 1' },
            { clicks: 4000, name: 'Master' },
            { clicks: 5000, name: 'Legend' },
            { clicks: 6000, name: 'Vetaren' },
            { clicks: 7000, name: 'War Lord' },
            { clicks: 8000, name: 'President' },
            { clicks: 9000, name: 'King' },
            { clicks: 10000, name: 'Death Lord' }
        ];

        // Achievement Definitions (UNCHANGED)
        const achievements = {
            'first_step': { name: 'First Step', clicks: 1, unlocked: false, icon: '‚≠ê' },
            'warmed_up': { name: 'Warmed Up', clicks: 100, unlocked: false, icon: 'üî•' },
            'no_pain_no_gain': { name: 'No Pain, No Gain', clicks: 500, unlocked: false, icon: 'üí™' },
            'grinding_hard': { name: 'Grinding Hard', clicks: 1000, unlocked: false, icon: 'üõ†Ô∏è' },
            'calm_down': { name: 'Calm Down!', clicks: 1500, unlocked: false, icon: 'üßò' },
            'dented_space_bar': { name: 'Dented Space Bar', clicks: 2000, unlocked: false, icon: '‚å®Ô∏è' },
            'still_going': { name: 'Still Going', clicks: 2800, unlocked: false, icon: 'üèÉ' },
            'addicted': { name: 'Addicted', clicks: 3000, unlocked: false, icon: 'üíâ' },
            'think_money': { name: 'Think of it as money!', clicks: 5000, unlocked: false, icon: 'üí∞' },
            'not_stopping': { name: 'Not stopping', clicks: 5500, unlocked: false, icon: 'üõë' },
            'why_still_here': { name: 'Why are you still here??', clicks: 6000, unlocked: false, icon: '‚ùì' },
            'touch_grass': { name: 'Bro touch grass', clicks: 8000, unlocked: false, icon: 'üåø' },
            'getting_paid': { name: 'Are you getting paid for this?', clicks: 9400, unlocked: false, icon: 'üí∏' },
            'ten_thousand': { name: 'TEN THOUSEND!', clicks: 10000, unlocked: false, icon: 'üíØ' },
            'beat_me': { name: 'Im out of ideas, you beat me', clicks: 15000, unlocked: false, icon: 'üëë' }
        };

        // --- FIREBASE/FIRESTORE LOGIC ---

        function getScoreDocRef(currentUserId) {
            const collectionPath = `/artifacts/${appId}/users/${currentUserId}/game_data`;
            return doc(db, collectionPath, 'clicker_score');
        }

        async function initializeFirestore() {
            if (!firebaseConfig) {
                console.error("Firebase config not available. Persistence disabled.");
                return;
            }
            app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);
            setLogLevel('Debug'); // Enable logging

            try {
                if (typeof __initial_auth_token !== 'undefined') {
                    await signInWithCustomToken(auth, __initial_auth_token);
                } else {
                    await signInAnonymously(auth);
                }
                
                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        userId = user.uid;
                        startScoreListener(userId);
                    } else {
                        console.error("User not signed in.");
                    }
                });
            } catch (error) {
                console.error("Firebase Auth error:", error);
            }
        }

        function startScoreListener(currentUserId) {
            const scoreRef = getScoreDocRef(currentUserId);
            onSnapshot(scoreRef, (docSnapshot) => {
                if (docSnapshot.exists()) {
                    const data = docSnapshot.data();
                    const savedClicks = data.clicks || 0;
                    
                    // Only update if the saved score is higher (to load highest score on startup)
                    if (savedClicks > clickCount) {
                        clickCount = savedClicks;
                        counterElement.textContent = clickCount.toLocaleString();
                        // Re-check everything when loading from persistence
                        for (const key in achievements) {
                            if (clickCount >= achievements[key].clicks) {
                                achievements[key].unlocked = true;
                            }
                        }
                        renderAchievements();
                        updateRankDisplay();
                    }
                    console.log("Score loaded/updated from Firestore:", clickCount);
                } else {
                    // Document doesn't exist yet, save the initial 0 score
                    saveScore();
                    console.log("No score found. Saving initial document.");
                }
            }, (error) => {
                console.error("Error listening to score:", error);
            });
        }

        function saveScore() {
            if (!db || !userId) {
                console.error("Firestore not ready. Cannot save score.");
                return;
            }
            const scoreRef = getScoreDocRef(userId);
            // Save current clickCount
            setDoc(scoreRef, { clicks: clickCount, lastUpdated: new Date() }, { merge: true })
                .then(() => console.log("Score saved:", clickCount))
                .catch(error => console.error("Error saving score:", error));
        }

        // --- GAME/UI LOGIC ---

        function getRandomColor() {
            const colors = [0x00FFFF, 0xFF00FF, 0xFFFF00, 0x00FF00, 0xFF69B4, 0x8A2BE2]; 
            return colors[Math.floor(Math.random() * colors.length)];
        }

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a1a); 

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, baseCameraY, baseCameraZ);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            gameContainer.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0x404040, 0.5); 
            scene.add(ambientLight);

            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const initialColor = getRandomColor(); 
            
            const material = new THREE.MeshLambertMaterial({ 
                color: initialColor, 
                emissive: initialColor, 
                emissiveIntensity: 0.8
            });
            cube = new THREE.Mesh(geometry, material);
            cube.position.y = cubeBaseY;
            scene.add(cube);

            cubeLight = new THREE.PointLight(initialColor, 1.5, 5); 
            cubeLight.position.set(0, cubeBaseY + 0.5, 0);
            cube.add(cubeLight); 

            const size = 20;
            const divisions = 20;
            gridHelper = new THREE.GridHelper(size, divisions, 0x00aaff, 0x00aaff); 
            gridHelper.material.opacity = 0.6;
            gridHelper.material.transparent = true;
            gridHelper.position.y = 0.01; 
            scene.add(gridHelper);

            // Initial UI Renders (will be updated by Firestore listener soon after)
            renderAchievements();
            updateRankDisplay(); 
            counterElement.textContent = clickCount.toLocaleString();

            // Event listeners
            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('keydown', onKeyDown, false); 
            document.addEventListener('keyup', onKeyUp, false); 
            gameContainer.addEventListener('click', performJumpAction, false);
            restartButton.addEventListener('click', restartGame, false);
        }

        // --- RESTART LOGIC ---

        function restartGame() {
            // Use double-click to confirm reset (since alert/confirm is forbidden)
            if (restartButton.dataset.confirm === 'true') {
                
                clickCount = 0;
                isHackrbandActive = false;
                counterElement.textContent = clickCount.toLocaleString();
                
                // Reset achievement state
                for (const key in achievements) {
                    achievements[key].unlocked = false;
                }

                saveScore(); // Save the zero score to Firestore
                
                renderAchievements();
                updateRankDisplay();

                restartButton.dataset.confirm = 'false'; // Reset confirmation state
                restartButton.textContent = "RESTART";
                showNotification("Game Reset", "Your clicks have been reset to 0.", 'bg-red-700 text-white');

            } else {
                restartButton.dataset.confirm = 'true';
                restartButton.textContent = "CLICK AGAIN TO CONFIRM RESET";
                showNotification("Warning", "Click RESTART again to confirm score wipe.", 'bg-red-500 text-white');
                
                // Timeout to revert text if user doesn't confirm
                setTimeout(() => {
                    if (restartButton.dataset.confirm === 'true') {
                        restartButton.dataset.confirm = 'false';
                        restartButton.textContent = "RESTART";
                    }
                }, 3000);
            }
        }

        // --- CHEAT MODAL LOGIC (UNCHANGED) ---

        function showCheatModal() {
            modal.classList.remove('hidden');
            cheatInput.value = '';
            cheatInput.focus();
            
            document.removeEventListener('keydown', onKeyDown, false);
            document.addEventListener('keydown', handleModalInput, false);
        }

        function hideCheatModal() {
            modal.classList.add('hidden');
            
            document.removeEventListener('keydown', handleModalInput, false);
            document.addEventListener('keydown', onKeyDown, false);
        }

        function checkCheatCode() {
            const input = cheatInput.value.trim().toUpperCase();
            
            if (input === cheatCode) {
                isHackrbandActive = true;
                showNotification("Cheat Activated", "Hold Spacebar for infinite clicks!", 'bg-green-500 text-white');
                updateRankDisplay();
            } else {
                showNotification("Invalid Code", "Try again or press Escape to close.", 'bg-red-500 text-white');
            }
            hideCheatModal();
        }
        
        function handleModalInput(event) {
            if (event.code === 'Enter') {
                event.preventDefault();
                checkCheatCode();
            } else if (event.code === 'Escape') {
                event.preventDefault();
                hideCheatModal();
            }
        }

        // --- RANK LOGIC (UNCHANGED) ---
        function getCurrentRank() {
            let currentRank = ranks[0]; 
            for (let i = 0; i < ranks.length; i++) {
                if (clickCount >= ranks[i].clicks) {
                    currentRank = ranks[i];
                } else {
                    break; 
                }
            }
            return currentRank;
        }

        function updateRankDisplay() {
            const rank = getCurrentRank();
            rankNameElement.textContent = rank.name;

            if (isHackrbandActive) {
                rankNameElement.textContent += " (HACKED)";
                rankNameElement.classList.remove('text-red-400');
                rankNameElement.classList.add('text-yellow-400', 'animate-pulse');
            } else {
                rankNameElement.classList.add('text-red-400');
                rankNameElement.classList.remove('text-yellow-400', 'animate-pulse');
            }
        }

        // --- ACHIEVEMENT LOGIC (UNCHANGED) ---
        function showNotification(title, message, className = 'bg-yellow-400 text-gray-900') {
            const notification = document.createElement('div');
            notification.className = `${className} p-3 rounded-xl shadow-2xl transition-all duration-300 transform translate-x-full opacity-0 pointer-events-auto min-w-[200px]`;
            notification.innerHTML = `<span class="font-extrabold">${title}</span><br>${message}`;
            notificationArea.appendChild(notification);

            setTimeout(() => {
                notification.style.transform = 'translateX(0)';
                notification.style.opacity = '1';
            }, 10);

            setTimeout(() => {
                notification.style.transform = 'translateX(100%)';
                notification.style.opacity = '0';
                setTimeout(() => notification.remove(), 500);
            }, 4000); 
        }

        function renderAchievements() {
            achievementListElement.innerHTML = ''; 

            const allAchievements = Object.values(achievements).sort((a, b) => a.clicks - b.clicks);

            let lastAchieved = { name: 'None', clicks: 0, icon: '‚ûñ', status: 'Achieved' };
            let upcoming = null;
            let upcomingAfter = null;
            
            for (const ach of allAchievements) {
                if (ach.unlocked) {
                    lastAchieved = { ...ach, status: 'Achieved' };
                } else if (!upcoming) {
                    upcoming = { ...ach, status: 'Upcoming' };
                } else if (!upcomingAfter) {
                    upcomingAfter = { ...ach, status: 'Next Goal' };
                    break; 
                }
            }

            const defaultNext = { name: 'Maxed Out', clicks: 'N/A', icon: 'üëë', status: 'Maxed' };

            const displaySlots = [
                { title: "Already Achieved", item: lastAchieved, color: 'text-green-400' },
                { title: "Upcoming", item: upcoming || defaultNext, color: 'text-indigo-400' },
                { title: "Upcoming after", item: upcomingAfter || defaultNext, color: 'text-yellow-400' }
            ];

            displaySlots.forEach(slot => {
                const li = document.createElement('li');
                
                let progressDisplay;
                if (slot.item.status === 'Achieved') {
                    progressDisplay = slot.item.clicks.toLocaleString() + ' Clicks';
                } else if (slot.item.clicks === 'N/A') {
                    progressDisplay = 'N/A';
                } else if (slot.title === 'Upcoming' && typeof slot.item.clicks === 'number') {
                    const needed = slot.item.clicks - clickCount;
                    progressDisplay = `${needed.toLocaleString()} needed`;
                } else {
                    progressDisplay = slot.item.clicks.toLocaleString() + ' total';
                }

                li.className = `flex flex-col text-xs p-2 rounded-lg border border-gray-600/50 bg-gray-700/50`;
                li.innerHTML = `
                    <div class="flex justify-between items-center mb-1 border-b border-gray-600/30 pb-1">
                        <span class="font-bold text-gray-300 uppercase text-[10px]">${slot.title}</span>
                        <span class="text-xs ${slot.color}">${slot.item.status}</span>
                    </div>
                    <div class="flex justify-between items-center">
                        <span class="font-medium ${slot.color}">${slot.item.icon} ${slot.item.name}</span>
                        <span class="text-sm font-bold text-white">${progressDisplay}</span>
                    </div>
                `;
                achievementListElement.appendChild(li);
            });
        }

        function checkAchievements() {
            let unlockedNew = false;
            for (const key in achievements) {
                const ach = achievements[key];
                if (!ach.unlocked && clickCount >= ach.clicks) {
                    ach.unlocked = true;
                    showNotification(`${ach.icon} ACHIEVEMENT UNLOCKED!`, ach.name);
                    unlockedNew = true;
                }
            }
            if (unlockedNew) renderAchievements();
        }

        function animate() {
            requestAnimationFrame(animate);

            cube.position.z = cubeZOffset;
            cubeLight.position.z = cube.position.z; 

            if (cube.position.y > cubeBaseY || cubeVelocity > 0) {
                cube.position.y += cubeVelocity;
                cubeLight.position.y = cube.position.y + 0.5;

                const heightOffset = cube.position.y - cubeBaseY; 
                const gravityFactor = 1 + heightOffset * gravityIncreaseFactor;
                const dynamicGravity = gravity * gravityFactor;

                cubeVelocity += dynamicGravity;

                if (cube.position.y < cubeBaseY) {
                    cube.position.y = cubeBaseY;
                    cubeVelocity = 0;
                    cubeLight.position.y = cubeBaseY + 0.5; 
                }
                
                const zoomOffset = heightOffset * zoomFactor; 
                const followY = heightOffset * 0.5; 

                camera.position.z = baseCameraZ + zoomOffset + cameraZOffset;
                camera.position.y = baseCameraY + followY;

            } else {
                camera.position.z = baseCameraZ + cameraZOffset;
                camera.position.y = baseCameraY;
            }

            if (cube.position.y > cubeBaseY) {
                cube.rotation.x += 0.02;
                cube.rotation.y += 0.03;
            } else {
                 cube.rotation.set(0, 0, 0);
            }
            
            camera.lookAt(cube.position);

            renderer.render(scene, camera);

            if (cubeZOffset !== 0) {
                cubeZOffset -= cubeZOffset * springBackSpeed;
                if (Math.abs(cubeZOffset) < 0.01) cubeZOffset = 0;
            }

            if (cameraZOffset !== 0) {
                cameraZOffset -= cameraZOffset * springBackSpeed;
                if (Math.abs(cameraZOffset) < 0.01) cameraZOffset = 0;
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onKeyDown(event) {
            if (event.code === 'Enter') {
                event.preventDefault();
                showCheatModal();
                return; 
            }

            if (event.code === 'Space' || event.keyCode === 32) {
                event.preventDefault();
                
                if (isHackrbandActive) {
                    performJumpAction();
                } else if (!isSpacebarPressed) {
                    isSpacebarPressed = true; 
                    performJumpAction();
                }
            }
        }

        function onKeyUp(event) {
            if (event.code === 'Space' || event.keyCode === 32) {
                if (!isHackrbandActive) {
                    isSpacebarPressed = false; 
                }
            }
        }

        function performJumpAction() {
            clickCount++;
            counterElement.textContent = clickCount.toLocaleString(); // Use toLocaleString for readability

            counterCard.style.transform = 'scale(1.1)';
            setTimeout(() => {
                counterCard.style.transform = 'scale(1.0)';
            }, 100);

            // UI UPDATES & SAVING
            checkAchievements();
            updateRankDisplay(); 
            saveScore(); // Save score after every click

            // 3D PHYSICS/VISUALS
            const newColor = getRandomColor();
            cube.material.color.set(newColor);
            cube.material.emissive.set(newColor); 
            cubeLight.color.set(newColor); 

            cubeVelocity = jumpForce;
            cubeZOffset = -clickZImpulse;
            cameraZOffset = clickZImpulse;
        }


        window.onload = function () {
            initializeFirestore();
            init();
            animate();
        };

    </script>
</body>
</html>
